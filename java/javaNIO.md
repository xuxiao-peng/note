## 输入/输出：概念性描述

### NIO简介

在 Java 编程中，一直使用 *流* 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。

NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式 且 块 I/O 的效率可以比流 I/O 高许多。

**注：现在传统的 I/O 也可以使用块传输，那么这个不是我们选择NIO的原因，根本原因使什么？**

### 为什么要使用 NIO?

NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。

### 流与块的比较

原来的 I/O 库(在 `java.io.*`中) 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。

*面向流* 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。

一个 *面向块* 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。

## 通道和缓冲区

### 概述

`通道 `和 `缓冲区 `是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。

通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。

### 什么是缓冲区？

`Buffer` 是一个对象， 它包含一些要写入或者刚读出的数据。 它的实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 *仅仅* 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

### 缓冲区分类

最常用的缓冲区类型是 `ByteBuffer`。一个 `ByteBuffer` 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。

`ByteBuffer` 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：

- `ByteBuffer`
- `CharBuffer`
- `ShortBuffer`
- `IntBuffer`
- `LongBuffer`
- `FloatBuffer`
- `DoubleBuffer`

每一个 `Buffer` 类都是 `Buffer` 接口的一个实例。 除了 `ByteBuffer`，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I/O 操作都使用 `ByteBuffer`，所以它具有所有共享的缓冲区操作以及一些特有的操作。

## 缓冲区核心

### 容量Capacity 

- **缓冲区能够容纳的数据元素的最大数量**。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)

### 上界Limit 

- **缓冲区里的数据的总数**，代表了当前缓冲区中一共有多少数据。

### 位置Position 

- **下一个要被读或写的元素的位置**。Position会自动由相应的 `get( )`和 `put( )`函数更新。

### 标记Mark 

- 一个备忘位置。**用于记录上一次读写的位置**。

### 操作的函数：

flip() 使 Limit 的值为 Position 的值，并把 Position 的值变为 0 (可以用做读数据的操作)

```java
 while (true) {
      buffer.clear(); // 清除此缓冲区。将位置设置为 0，将限制设置为容量，并丢弃标记。
      int r = fcin.read( buffer ); // 从此通道读取数据报。 返回：读取的字节数，可能为零，如果该通道已到达流的末尾，则返回 -1
      if (r==-1) {
        break;
      }
      buffer.flip();  // 反转此缓冲区。首先将限制设置为当前位置(即我所有读取的数据)，然后将位置设置为 0。

      fcout.write( buffer );
    }
```



## 

