## 解决可见性问题

可见性问题和有序性问题，是因为 CPU 缓存 和 jvm 的编译优化而造成的，解决的方式也很简单，就是**禁用 CPU 缓存和编译优化**。这倒是一个很简单的方法，但这样的话，我的程序的性能就很糟糕了。

正确的方式时“按需禁用”缓存， 这个“**按需禁用**”可以由程序员控制，按需禁用缓存和编译优化的方法即可。

在这里引入 java 的三个关键字 **volatile**、**synchronized** 和 **final **及六项 **Happens-Before 规则**，

## volatile 

volatile 中文意思是 “易变的、不稳定的”，这也正是这个关键字 volatile 的语义

当使用这个关键字时，就等于告诉虚拟机，这个变量极有可能会被某些线程修改，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。

## Happens-Before 规则

**Happens-Before**  ---  **前面一个操作的结果对后续操作是可见的**

所以比较正式的说法是：Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。

### 1. 程序的顺序性规则

这条规则是指在一个线程中，按照程序顺序，前面的操作先发生于后续的任意操作。

### 2. volatile 变量规则

这条规则是指对一个 volatile 变量的写操作， 先发生于后续对这个 volatile 变量的读操作。

### 3. 传递性

这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

### 4. 管程中锁的规则

**管程**是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。

这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。

管程中的锁在 Java 里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。

```java

synchronized (this) { // 此处自动加锁
  // x 是共享变量, 初始值 =10
  if (this.x < 12) {
    this.x = 12; 
  }  
} // 此处自动解锁
```

### 5. 线程 start() 规则

这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。

```java
Thread B = new Thread(()->{
  // 主线程调用 B.start() 之前
  // 所有对共享变量的修改，此处皆可见
  // 此例中，var==77
});
// 此处对共享变量 var 修改
var = 77;
// 主线程启动子线程
B.start();

```

### 6. 线程 join() 规则

这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对**共享变量**的操作。

```java
Thread B = new Thread(()->{
  // 此处对共享变量 var 修改
  var = 66;
});
// 例如此处对共享变量修改，
// 则这个修改结果对线程 B 可见
// 主线程启动子线程
B.start();
B.join()
// 子线程所有对共享变量的修改
// 在主线程调用 B.join() 之后皆可见
// 此例中，var==66
```



### 7.线程中断规则

对线程`interrupt()`方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过`Thread.interrupted()`方法检测到是否有中断发生。

### 8.对象终结规则

一个对象的初始化完成(构造函数执行结束)先行发生于它的`finalize()`方法的开始。

## final