

## 学习目的

- [ ] MySQL的框架有几个组件, 各是什么作用? 

- [ ] Server层和存储引擎层各是什么作用?

- [ ] you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?

- [ ] 对于表的操作权限验证在哪里进行?

- [ ] 执行器的执行查询语句的流程是什么样的? 

## mysql框架

服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是连接管理、解析与优化、存储引擎。

![](.\img\mysql详细架构图.jpg)

## 连接器

我们连接数据库时，进行的操作。

```reStructuredText
执行的流程

1、输入账号密码

2、验证权限并读取权限，以后的每次读取都会用此时查到的权限验证

3、 建立连接成功
```

**注：** 如果在连接成功之后，更改该用户权限，那么不会立即生效。当用户重新登录时才会生效

建立连接成功之后，会把连接信息维护在一张表里面，用命令 `show processlist` 查看。可以看到

```
+----+------+----------------+------+---------+------+----------+------------------+
| Id | User | Host           | db   | Command | Time | State    | Info             |
+----+------+----------------+------+---------+------+----------+------------------+
|  2 | root | localhost:5622 | NULL | Query   |    0 | starting | show processlist |
|  4 | root | localhost:5641 | NULL | Sleep   |    5 |          | NULL             |
+----+------+----------------+------+---------+------+----------+------------------+
```

如果连接过后长时间没有任何操作，那么就会进入 Sleep 状态 。

如果 Time 超过了 8 个小时（由设置参数 wait_timeout控制 ），那么这个连接就会断开。

### 拓展

#### 长连接

长连接是相对于短连接来说的。长连接指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。我理解 MySQL 默认的超时时间 8 小时，就属于一个长链接。

#### 短连接

是指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。

长连接主要用于在**少量客户端**与服务端的**频繁通信**，因为这时候如果用短连接频繁通信常会发生 Socket 出错，并且频繁创建 Socket 连接也是对资源的浪费。

#### 长连接的管理

使用长连接后，随着连接数不断增加，会导致内存占用升高，因为 MySQL 在操作过程中会占用内存来管理连接对象，只有等到连接断开后才会释放。

如果连接一直堆积，就会导致内存占用过大，被系统强行杀掉，也就是会出现 MySQL 重启。

如何解决这个问题呢？

1. 定期断开长连接

   MySQL 5.7+ 的版本中提供了 `mysql_reset_connection` 来重新初始化连接资源，这时不需要重新连接，就可以将连接恢复到刚刚创建完时的状态；

   对于 `mysql_reset_connection` ，MySQL 官网的描述是这样的：

   > 将连接重置，清空连接状态。
   > 类似于重新连接，但是不会关闭当前连接，也不会进行重新鉴权。

2. 数据库连接池

   > 数据库连接池，就是服务器应用建立多个连接到数据库，还没有用的连接就放到连接池上，要的时候就向连接池取，这样比没有连接时再建立新的连接（TCP 建立连接是需要时间的）时要快很多，从而提高传输效率。

如 Spring 框架中，它实现了一个持久连接池，允许其他程序、客户端来连接，这个连接池将被所有连接的客户端共享使用，连接池可以加速连接，也可以减少数据库连接，降低数据库服务器的负载。



## 查询缓存

连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。

如果命中查询缓存，那么会在**检验完用户的操作权限后**（如果有该操作权限就）直接返回结果，不用执行后面的所有操作，速度会相应提升。

**注意：** ①因为缓存结构是 HASH 结构以 SQL 语句为 key ，查询结构集为 value。 所以须要一样的 SQL 语句才能执行查询缓存，多一个空格，一个标点符号都不行

​		 	 ②如果有该表有修改操作，那么这个表的所有查询缓存都会失效！

因为查询缓存很容易失效，所有我们很少使用它。可以将query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存 。 在需要查询缓存的语句中，加入SQL_CACHE 显式指定 ，例如：

```sql
select SQL_CACHE * from T where ID=10；
```

## 分析器

在没有命中查询缓存之后，就会开始执行这条 SQL 语句，

对 SQL 语句 进行词法分析与语法检查，如果有错误会在此阶段检查出来。

```
select * from T where ID=10；
```

### 词法分析

在这条语句中，会按照单词来分析每个是什么意思： 这是一个 `select` 查询操作 `*` 查询所有字段 ` T` 查询 T 表 `where`  后面的是查询条件 `ID` 是一个列名。  

### 语法分析

在词法分析检查无误之后，会进行语法分析。这个阶段只要会检查你这条 SQL 语句是否是正确的 SQL 语句

如果错误会抛出 `You have an error in your SQL syntax ` 的错误

## 优化器

在进行了 分析器 检查 SQL 问题之后，就进行到 优化器部分。

优化器的工作主要是当 一个 SQL 语句中用到了多个索引或者 join 连接时，我们用哪个索引更好的问题。

例如如下 SQL语句

```sql
select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

这条语句中，

- 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。

- 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。



这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

## 执行器

Mysql 在经过 分析器 知道了我们要执行这个 sql 的目的，通过  优化器 知道了我们该怎么去做，接下来就该到了执行的阶段。

在执行时，会判断当前用户是否有该表的操作权限，如果没有就 报没有权限的错误。

如果有就打开表，按照表的引擎找到对应的 API 接口

### 没有索引

比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：
1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如
果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 

### 有索引

对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接
口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的 



注：如果你开启了慢查询日志，慢查询日志中 rows_examined  会查出这条语句扫描了多少行	



## 思考题

###  题目

如果表 T 中没有字段 k，而你执行了这个语句 select * from T
where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in
‘where clause’” 

### 答案

分析器

预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。







