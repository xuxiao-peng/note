## 学习目的

- [ ] 日志系统的目的



### 日志系统简介

在 MySQL 中 如果每一次更新操作都需要马上写进磁盘，需要先到磁盘找到对应的记录，然后才能进行更新。整个过程 IO 成本和查询成本都很高。于是 MySQL 参考我们平时写文件的缓存层，设计了一块日志系统用来充当缓冲。

这就是 MySQL 里面的 WAL（Write-Ahead Logging ） 技术，先写日志，然后写磁盘。

## redo log(重做日志)

当有一条更新操作时，InnoDB 会先记录写到 redo log 里。再更新到内存中。 InnoDB 引擎在空闲时，将这个操作记录更新到磁盘里面。

redo log 的大小是固定的，由我们自己配置，配置一组4个文件，每个文件大小 1 GB,  那么就有 4GB 的操作空间。

![1557482184667](./img/redoLog图.png)

`white pos` 表示当前记录的位置，一边写一边移动。写到 ib-logfile-3 的末尾就回到 0号文件 开头。

`checkpoint` 表示 当前要擦除的位置，也是往后推移并循环的，擦除记录前要把记录更新到数据文件 

中间绿的的部分是代表 redolog 空余的部分，用来记录新的操作。

如果绿色部分空了，那么需要先擦除一些记录，把 `checkpoint` 推进以下，制造一些空余空间。

有了这个记录就能明确当数据库异常重启时，没有写到磁盘的数据的恢复问题。

## binlog(归档日志)

我们刚刚的 redo log 只是在 InnoDB 引擎的日志文件，在我们的  server 端也有自己的日志 binlog 日志。



因为 binlog 只能用于归档。不提供  crash-safe 功能，而 InnoDB 是另一个公司以插件形式引入 MySQL 的既然只依靠 binlog 是没有 crash-safe 能力，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。

两者的区别是

1. redo log 是 InnoDB 特有，而 binlog 是属于整个Server ,所有引擎都可以使用它。
2. redo log 记录的是物理数据，记录的是在数据页上做了什么修改,是正在执行中的 dml 以及 ddl 语句；而 binlog 是逻辑日志，记录的是语句的原始逻辑，已经提交完毕之后的 dml 以及 ddl sql 语句，如「给 ID=2 的这一行的 c 字段加 1」；
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。



## 一条更新语句的执行流程

### update 语句时的内部流程。

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果
ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁
盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，执行更新操作。把这个值加上 1，比如原来是 N，现在就是 N+1，得到
新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时
redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状
态，更新完成。 

### 图文解释

![一条更新语句的执行流程](C:\Users\P\Desktop\笔记本\mysql\img\一条更新语句的执行流程.png)

在这上面 `redo log` 会有两阶段提交，由  `prepare -> commit` 状态

### 两阶段提交

其实这就是所谓的两阶段提交，即 COMMIT 会被自动的分成 prepare 和 commit 两个阶段。

![](C:\Users\P\Desktop\笔记本\mysql\img\redo log 两阶段提交.jpg)

MySQL 在 prepare 阶段会生成 xid，然后会在 commit 阶段写入到 binlog 中。在进行恢复时事务要提交还是回滚，是由 Binlog 来决定的。

由上面的二阶段提交流程可以看出，通过两阶段提交方式保证了无论在任何情况下，事务要么同时存在于存储引擎和 binlog 中，要么两个里面都不存在。

这样就可以保证事务的 binlog 和 redo log 顺序一致性。一旦阶段 2 中持久化 Binlog 完成，就确保了事务的提交。

此外需要注意的是，每个阶段都需要进行一次 fsync 操作才能保证上下两层数据的一致性。

> PS：记录 Binlog 是在 InnoDB 引擎 Prepare（即 Redo Log 写入磁盘）之后，这点至关重要。
> 另外需要注意的一点就是，SQL 语句产生的 Redo 日志会一直刷新到磁盘（master thread 每秒 fsync redo log），而 Binlog 是事务 commit 时才刷新到磁盘，如果 binlog 太大则 commit 时会慢。

[参考链接]: https://hoxis.github.io/mysql-zhuanlan-02-redolog-binlog.html	"参考链接"

## 恢复步骤

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

1、首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；

2、然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。

这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。

当遇到 crash 时，恢复的过程也非常简单：

1、扫描最后一个 Binlog 文件，提取其中的 xid；
2、重做检查点以后的 redo 日志，搜集处于 prepare 阶段的事务链表，将事务的 xid 与 binlog 中的 xid 对比，若存在，则提交，否则就回滚；

总结一下，基本顶多会出现下面是几种情况：

- 当事务在 prepare 阶段 crash，数据库 recovery 的时候该事务未写入 Binary log 并且存储引擎未提交，将该事务 rollback。
- 当事务在 binlog 阶段 crash，此时日志还没有成功写入到磁盘中，启动时会 rollback 此事务。
- 当事务在 binlog 日志已经 fsync 到磁盘后 crash，但是 InnoDB 没有来得及 commit，此时 MySQL 数据库 recovery 的时候将会读出 binlog 中的 xid，然后告诉 InnoDB 提交这些 xid 的事务，InnoDB 提交完这些事务后会回滚其它的事务，使存储引擎和二进制日志始终保持一致。

总结起来说就是如果一个事务在 prepare 阶段中落盘成功，并在 MySQL Server 层中的 binlog 也写入成功，那这个事务必定 commit 成功。

## 总结

介绍了 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog。

redo log 用于保证 crash-safe 能力。`innodb_flush_log_at_trx_commit` 这个参数设置成 1 的时候，表示**每次事务的 redo log 都直接持久化到磁盘**。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。

`sync_binlog` 这个参数设置成 1 的时候，表示**每次事务的 binlog 都持久化到磁盘**。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。