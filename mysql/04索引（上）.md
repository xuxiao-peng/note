在我们一条 SQL 很慢的时候，我们通常第一步就会想到我是不是要加索引了。

MySQL 官方给出的定义

> 索引是帮助 MySQL 高效获取数据的数据结构。

## InnoDB索引实现

虽然 InnoDB 也使用 B+ 树作为索引结构，但具体实现方式却与 MyISAM 截然不同。

第一个重大区别是 InnoDB 的**数据文件本身就是索引文件**。

在 InnoDB 中，表数据文件本身就是按 B+ 树组织的一个索引结构，这棵树的叶节点 data 域保存了**完整的数据记录**。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。

另外，第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储**相应记录主键的值而不是地址**。

对于聚簇索引存储来说，行数据和主键 B+ 树存储在一起，**辅助索引**只存储辅助键和主键，主键和非主键 B+ 树几乎是两种类型的树。

对于非聚簇索引存储来说，主键 B+ 树在叶子节点存储指向真正数据行的指针，而非主键。

------

为了更形象说明这两种索引的区别，我们假想一个表如下图存储了 4 行数据。其中 Id 作为主索引，Name 作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。

[![元数据](https://www.github.com/hoxis/token4md/raw/master/1543820056150.jpg)](https://www.github.com/hoxis/token4md/raw/master/1543820056150.jpg)

[![检索过程的差异](https://www.github.com/hoxis/token4md/raw/master/1543820086047.jpg)](https://www.github.com/hoxis/token4md/raw/master/1543820086047.jpg)

对于聚簇索引，若**使用主键索引进行查询**，`where id = 14` 这样的条件查找主键，则按照 B+ 树的检索算法即可查找到对应的叶节点，之后获得行数据。

若使用**辅助索引进行查询**，对 Name 列进行条件搜索，则需要两个步骤：

1、第一步在辅助索引 B+ 树中检索 Name，到达其叶子节点**获取对应的主键**。
2、第二步根据主键在主索引 B+ 树种再执行一次 B+ 树检索操作，最终到达叶子节点即可获取整行数据。这个过程称为**回表**。

## 聚簇索引的优势在哪？

1、由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键 Id 来组织数据，获得数据更快。

2、辅助索引使用主键作为**指针**而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作。

使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是 InnoDB **在移动行时无须更新辅助索引中的这个指针**。

也就是说行的位置会随着数据库里数据的修改而发生变化，使用聚簇索引就可以保证不管这个主键 B+ 树的节点如何变化，辅助索引树都不受影响。