# 分类

MySQL 中锁分为 三类，分别为

1. 全局锁
2. 表锁
3. 行锁

# 全局锁

对整个数据库实例加锁，MySQL 给全局加读锁的方法（FTWRL ）。当使用了这个语句后，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 



应用场景：做全库逻辑备份 。

# 几种类似全局锁实现的方式

## 官方自带的mysqldump

当 mysqldump 使用参数  `–single-transaction` 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。 

### 缺点： 有的数据库不支持事务

## 设置全库只读

`set global readonly=true `，可以使全库进入只读状态。

但 `set global readonly=true` 有的时候会用来判断这个库是主库还是从库。

而且 `set global readonly=true` 没有异常处理机制，`FTWRL  ` 如果报错，MySQL 会自动释放这个全局锁，整个库回到正常状态。  而 `set global readonly=true` 客户端发生异常了之后，还是保持原样。

# 表级锁

分类： 表锁，元数据锁

## 表锁

```sql
lock tables … read/write    加锁
unlock tables				绑锁
```

用 lock tables 语法，会限制其他线程的读写，自己的也会被限制住。

例如 

```
lock tables t1 read, t2 write; 
```

别的线程只能对 `t1` 写 ，`t2` 读，如果对 `t1` 读或 `t2` 写都会被阻塞。  **自己也只能对 t1 读，和对t2 写**



## 元数据锁（MDL：metadata lock）

元数据锁不需要显式使用，在访问一个表的时候会**自动加上**。

它的作用主要是保证读写的正确性。

- 表的增删改查操作，需要先加 MDL 读锁；
- 表结构变更操作，需要先加 MDL 写锁
- MDL 读锁之间不互斥，多个线程可以同时对一张表增删改查。
- MDL 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。

如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到**整个事务提交后再释放**。

因此，需要避免长事务，因为长事务会造成锁一直不能释放，后续的操作会堆积，这个库的线程很快就会爆满。

# 行锁

MySQL 是有引擎层实现的，不在 server 中实现，MyISAM 就不支持行锁。

## 两阶段协议：

- 需要的时候加上
- 事务结束时释放

当需要锁多个行时，尽量把影响并发的锁往后放，这样可以最大程度的减少事务之间的锁等待，提升并发度。

**另外，InnoDB 的 行锁建立在索引的基础上，锁的是索引。因此，如果更新的列没建索引会锁住整个表。**

# 死锁和死锁检测 

![死锁检验](img\死锁检验.png)

不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源。



## 死锁的对策

1. 设置超时时间`innodb_lock_wait_timeout `  

   不方便判断是否是死锁还是简单的所等待的问题。

2. 发起死锁检测，主动回滚死锁链条中的某一个事务  `innodb_deadlock_detect`

   发生死锁后，InnoDB 一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务。

## 如何避免死锁

另外，我们可以采取以下方式避免死锁：

- 通过表级锁来减少死锁产生的概率；
- 多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；
- 同一个事务尽可能做到一次锁定所需要的所有资源。

另外，死锁检测也非常耗费资源，判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。

比如有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的，这将消耗大量的 CPU 资源。

