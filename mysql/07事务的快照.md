# 引题

我们之前学习了隔离级别和锁，在隔离级别里有一个**可重复读**，锁里有个**行锁**。

- 可重复读：事务开启期间，看不到别的事务的更新操作的结果；
- 行锁：有事务 1 和 事务 2 同时开启事务，但 事务1 先更新 c 数据为c1 ，若此时事务 2 想来更新数据，会被锁住，直到事务1的更新操作释放锁

矛盾来了：事务 2 获取到行锁时，看到的是哪个数据呢？

按照 可重复读 的定义，我事务开启时读不到更新操作，所以我读取的会是原始的没有更新过的数据 c。然后的 数据更新为 c2。

但这样的话 c1 是否就没有了，事务1 的更新操作就会被丢失的。那么具体情况是什么呢？

# 实验

## 建立一张表

```sql
CREATE TABLE `t` (
`id` int(11) NOT NULL,
`k` int(11) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(id, k) values(1,1),(2,2);
```

## 做如下操作

![img](img\事务快照的事务操作.png)

> 说明：
> 1、begin/start transaction 运行后其实并**不会立即启动事务**，执行第一个操作 InnoDB 表的语句时才会真正启动；
> 2、显示启动事务：start transaction with consistent snapshot

## 实验结果：

很容易看到实验结果：

- A 读到的值是 1
- B 读到的值是 3

看上去 B 事务违反了可重复读隔离级别的概念，为啥呢？

# 引入视图的概念

## mysql 中有两个视图的概念



一、常说的视图：view

① 是用查询语句定义的**虚拟表**；
② 在调用时执行查询，并生成结果；
③ 创建方法：`create view...`；

二、MVCC 中的一致性视图（consistent read view）

① 用于**支持隔离级别的实现**：RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）
② 没有物理结构，作用是事务执行期间**用来定义我能看到什么数据**；
③ 其中，可重复读：每个事务启动是都会重建读视图，整个事务存在期间都用这个视图；
④ 其中，读提交是指：每一个语句执行前都会重新算出一个新的视图；

# 引入快照的概念

要保持隔离性，在重复读隔离级别下，**事务启动时会生成整个库的快照**。

快照是什么呢？

在说快照前，先说一下下**数据的版本**问题

## 数据版本

每一个事务都有一个**按申请顺序严格递增的**  唯一事务ID，称为 transaction id ，

我们的数据也是多版本存在的，一旦事务更新了数据，都会生成一个数据版本，把唯一事务ID 记录到 row trx_id 中。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

 ![数据版本](img\数据版本.png)

虚线中的表示我们的 4个版本，其中 V4 是最新的版本，是被 事务id 为25的事务修改的。

图中 黑色字体的 ` U1  U2  U3` 是记录在 undo log 中的。

而V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来 。

## 事务启动

可重复读隔离级别下，事务的属性是这样的：可以看到所有已提交的更新，所有未提交的更新都不能看到。对于同一行数据，以最新一次的事务提交为数据基准。

另外，事务启动后，很可能存在其他**活跃事务（启动且未提交）**，我们把这些活跃事务的 id 组成一个数组，并且记数组中 trx_id 最小的记为**低水位**，trx_id 最大的记为**高水位**。

因此，所有的事务 id 可以分成下图这种：

![img](img\事务启动时的活跃事务数组.png)

- trx_id 在绿色部分，已提交，可见
- 在红色部分，表示这个版本是由将来启动的事务生成的 ，不可见
- 黄色部分
  - trx_id 在数组中，表示这个版本是由还没提交的事务生成的 ，不可见
  - trx_id 不在数组中，表示这个版本是已经提交了的事务生成的 ，可见

  

所以我们引题中的事务操作如下

![引题的事务操作](img\引题的事务操作.png)

所以 A 会是 1，那么按照你个的逻辑 为什么 B 会是 3 呢？ 为什么 事务B 为什么会 读到 102 的数据呢？

# 更新的逻辑

就是更新数据都是**先读后写**的，而这个读，只能**读当前的最新值**，称为**当前读**（current read），

读操作也可以是当前读，我们可以加锁实现它：

```sql
读锁（S 锁，共享锁）：mysql> select k from t where id=1 lock in share mode;
写锁（X 锁，排他锁）：mysql> select k from t where id=1 for update;
```

