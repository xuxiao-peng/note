# 几个核心概念

## 脏页

当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页” 

## 干净页

内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。 

![1558070781576](C:\Users\P\Desktop\笔记本\mysql\img\更新和flush过程.png)



我们偶尔执行慢可能就是因为我们在刷新脏页的过程中。

# 什么情况会引发数据库的 flush 过程呢 

## 一、redo log写满了

对应的就是 InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。

![1558070894449](C:\Users\P\Desktop\笔记本\mysql\img\redo log 状态图.png)

这里，我们redo log写满了，我们要向磁盘写入我们脏页（图中绿色部分）的数据，对应的所有脏页都 flush 到磁盘上 。

## 二、系统内存不足

当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。 

为什么不直接将内存放弃，直接从磁盘读入数据页，配合redo log呢？

这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：

- 一种是内存里存在，内存里就肯定是正确的结果，直接返回；
- 另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高 

## 三、对应的就是 MySQL 认为系统“空闲”的时候 

## 四、对应的就是 MySQL 正常关闭的情况 

# 优化一、二两种情况对性能的影响

第一种是“redo log 写满了，要 flush 脏页”，这种情况是 InnoDB 要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为 0。

第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。InnoDB 用缓
冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态： 

- 第一种是，还没有使用的；
- 第二种是，使用了并且是干净页；
- 第三种是，使用了并且是脏页。 

InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很
少。 

而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：
1. 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；
2. 日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。 

所以InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况 

## InnoDB 刷脏页的控制策略 

