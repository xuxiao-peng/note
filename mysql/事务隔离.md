## 事务的四大特性（ACID）

- 原子性（atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚

- 一致性（consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

- 隔离性（isolation）：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离

- 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

## 数据库事务的隔离

在介绍事务隔离之前我们先介绍我们隔离之后会发生什么后果？

### **（1）脏读**

所谓脏读就是指在事务在处理过程中，有另一事务读取了该数据


例如： 你妈妈给你打生活费 1000，开启事务，结果你妈不小心手一抖给你转了 1 W。你此时正好没钱，查数据看钱到账没。结果一看发现卡上有1万元，正在这时然而你妈机智的发现钱转多了，又回滚了操作。饿了两天的你准备到食堂大吃一顿，点餐付钱的时候缺发现余额不足，非常郁闷。

这里的主要问题：事务没有提交，然后却被其他事务读取数据
**解决方案**：开启  Read committed 
也就是说采用读提交方式，只要我没有提交事务，那么另外的事务就不能读取该数据

### **（2）不可重复读**

不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

我们开启了 `Read committed` 之后又会遇到另外的一个问题。

例如：小明骗妈妈说学校要交补课费，给小明了两千大洋。小明知道了这件事后准备去享受生活，当小明和女朋友去逛街买单前，查看账户有2100元（此时事务开启）。此时小明妈妈被小李妈妈提醒得知被骗了，于是乎把小明卡上的钱全部转到其他卡上去了。小明此时并不知情，付款时得知余额不足，在女朋友面前非常尴尬。

在这里我们的小明妈妈，并没有读取数据，而是直接修改卡上的钱，使之变为0。不称之为脏读，这里的主要问题是重复读取的问题

**解决方案**：Repeatable read
重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

### **（3）幻读**

事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

解决方案：Serializable 序列化

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

## 事务隔离级别



上面我们提到的几种解决方案其实就是我们的四种事务隔离级别

从高到低依次是：

|             级别             | 解释                                                         | 作用                                                         |
| :--------------------------: | :----------------------------------------------------------- | ------------------------------------------------------------ |
|    Serializable（串行化）    | 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 | 可避免脏读、不可重复读、幻读的发生                           |
|  Repeatable read（重复读）   | 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的 | 可避免脏读、不可重复读的发生                                 |
|  Read committed （读提交）   | 一个事务提交之后，它做的变更才会被其他事务看到               | 可避免脏读的发生                                             |
| Read uncommitted（读未提交） | 一个事务还没提交时，它做的变更就能被别的事务看到             | 一个事务还没提交时，它做的变更就能被别的事务看到 最。低级别，任何情况都无法保证 |

**注意** 隔离级别越高，效率越低



## 事务隔离的实现

我们根据一个“可重复读”，来理解事务隔离是怎么实现的。

在MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新
值，通过回滚操作，都可以得到前一个状态的值 。

事务的机制是通过**视图（read-view）**来实现的并发版本控制（MVCC），不同的事务隔离级别创建读视图的时间点不同。

- 可重复读是每个事务重建读视图，整个事务存在期间都用这个视图。
- 读已提交是每条 SQL 创建读视图，在每个 SQL 语句开始执行的时候创建的。隔离作用域仅限该条 SQL 语句。
- 读未提交是不创建，直接返回记录上的最新值
- 串行化隔离级别下直接用加锁的方式来避免并行访问。

这里的视图可以理解为**数据副本**，每次创建视图时，将当前**已持久化的数据**创建副本，后续直接从副本读取，从而达到数据隔离效果。

### MVCC的控制方式

我们每一次的修改操作，并不是直接对行数据进行操作。

比如我们设置 id 为 3 的行的 A 属性为 10，并不是直接修改表中的数据，而是新加一行。

同时数据表其实还有一些**隐藏的属性**，比如每一行的事务 id，所以**每一行数据可能会有多个版本**，每一个修改过它的事务都会有一行，并且还会有**关联的 undo 日志**，表示这个操作原来的数据是什么，可以用它做回滚。

那么为什么要这么做？

因为如果我们直接把数据修改了，那么其他事务就用不了原先的值了，违反了事务的一致性。

那么一个事务读取某一行的数据到底返回什么结果呢？

取决于隔离级别，如果是 Read Committed，那么返回的是**最新的事务的提交值**，所以未提交的事务修改的值是不会读到的，这就是 Read Committed 实现的原理。

如果是 Read Repeatable 级别，那么只能返回发起时间比当前事务早的事务的提交值，和比当前事务晚的删除事务删除的值。这其实就是 MVCC 方式。

### 例子

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志（undo log）里面就会有类似下面的记录。 

![事务隔离示例](.\img\事务隔离示例.png)

当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。 

同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。 



注：系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。 

### 长事务

如果你是一个长事务的话，就会发生有很多回滚日志的情况，因为有事务在使用所有无法删除。



长事务，意味着系统里有很多事务识图，由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。 



***所以我们要尽量避免使用长事务***



## 事务的启动方式



1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语
句是 rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一
个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主
动执行 commit 或 rollback 语句，或者断开连接。

有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致
接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。

因此，我会建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用 commit work and chain 语法。



在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。
