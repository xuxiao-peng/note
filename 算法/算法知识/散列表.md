

散列表（Hash 表）

一种非常常见的数据结构。

# 散列的思想

它用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表 。

它是一种 键-值 （key-value）存储数据的结构，我们把输入的键 key 用哈希函数，转换为 hash 值。就可以吧 key 转换为一个确定的位置，然后把 值 value 放到这个数组对应的位置

# 散列函数

散列函数也就是哈希函数，在我们的散列表中起着非常关键的作用。

他就是一个函数， 我们可以 把它定义为 hash(key)  ，其中 key 是我们传入的键， 类似的伪代码是

```c#
int hash(String key) {
    // 获取后两位字符
    string lastTwoChars = key.substr(length-2, length);
    // 将后两位字符转换为整数
    int hashValue = convert lastTwoChas to int-type;
    return hashValue;
}
```

由于设计一个散列函数式很复杂的，上面使我们简化后的伪代码。它设计的基本要求是：

1. 散列函数计算得到的散列值是一个非负整数
2. 如果 key1 = key2 ，那么 hash(key1) = hash(key2)
3. 如果 key1 != key2 ,  那么 hash(key1)!=hash(key2)

其实前面两点是非常好满足的，第三点现在满足有点困难，因为在现有的 hash 算法（例如 MD5、SHA、CRC）

中，存在多个 key 的 hash 值可能相同的情况，这种情况称之为散列冲突。

# 散列冲突

为了解决我们的散列冲突 ，那么就引入了两类解决方案。分别是 **开放寻址法** 和 **链表法** 

## 开放寻址法

### 核心思想

如果出现散列冲突，就重新探测一个空闲位置，将其插入 

#### 线性探测法

##### 插入数据

当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

##### 查找数据

我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。

##### 删除数据

为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测

总结：最坏时间复杂度为 O(n)

#### 二次探测

线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。 

#### 双重散列

使用一组散列函数，直到找到空闲位置为止。 

#### 线性探测法的性能描述：

用“装载因子”来表示散列表中空位多少。

**公式：散列表装载因子=填入表中的个数/散列表的长度。**

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降 

## 链表法（更常用）

##### 插入数据

当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。

##### 查找或删除数据

当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数， m表示散列表中槽的个数，所以是时间复杂度为O(k)。

# 如何设计一个好的散列函数

## 要点

1. 支持快速的查询、插入、删除操作；
2. 内存占用合理，不能浪费过多空间；
3. 性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。

## 关键方案



1. 设计一个合适的散列函数；

2. 定义装载因子阈值，并且设计动态扩容策略；
3. 选择合适的散列冲突解决方法。

## 如何设计合适的散列函数



1. 要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。

2. 除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。

3. 常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。

## 如何根据装载因子动态扩容？

### 如何设置装载因子阈值？

①可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，插入数据的时间复杂度使用摊还分析法。
②装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如何权衡？如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果
内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。

### 如何避免低效扩容？分批扩容

①分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。
②分批扩容的查询操作：先查新散列表，再查老散列表。
③通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。

## 如何选择散列冲突解决方法？

### 常见的2种方法

开放寻址法和链表法

### 开放寻址法

#### 优点

有效利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化简单。

#### 缺点

删除数据代价高，遇到冲突的代价也很高。比链表法更消耗内存

#### 总结

所以当数据量比较小、装载因子小的时候，适合采用开放寻址法 

### 链表法 

#### 优点

1. 对内存的利用率要高--------需要时才创建，不用实现声明好
2. 对装载因子的容纳要高

#### 缺点

因为链表是分散存储的，所以 对CPU 缓存不友好。

## 总结

大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。

但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。 

# 思考

## 1.Word文档中单词拼写检查功能是如何实现的？

字符串占用内存大小为8字节， 20万单词占用内存大小不超过20MB，所以用散列表存储20万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。

## 2.假设我们有10万条URL访问日志，如何按照访问次数给URL排序？

字符串占用内存大小为8字节， 10万条URL访问日志占用内存不超过10MB，通过散列表统计url访问次数，然后用TreeMap存储散列表的元素值（作为key）和 数组下标值（作为value）

## 3.有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？

分别将2个数组的字符串通过散列函数映射到散列表，散列表中的元素值为次数。注意，先存储的数组中的相同元素值不进行次数累加。最后，统计散列表
中元素值大于等于2的散列值对应的字符串就是两个数组中相同的字符串。

# TODO

基于 hash 表的  LRU 算法



